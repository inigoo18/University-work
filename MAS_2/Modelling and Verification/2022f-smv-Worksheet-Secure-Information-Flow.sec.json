{"nextID":46,"title":"Worksheet: Secure Information Flow","editMode":false,"elements":[{"id":0,"alias":"md-intro","type":"text-input","locked":false,"hidden":true,"state":{"text":"In these notes we will examine how programs may leak confidential information and\nalso how static analysis can be used to verify that a program does *not* leak \ninformation. This is called *secure information flow*.\n\n\n# Task 1: Direct Flows\n\nWe start with a simple challenge: the program below reads a secret value from\na database (line 1) and stores it in the variable `secret`; it then does some \ncomptuation (line 2), and outputs the variable `public` (line 3). Your task now \nis to add/change the computation(s) of the program, such that it leaks (through\noutput) the value of `secret`. In other words insert some instruction(s) that \ntransfer(s) data from `secret`to `public`."}},{"id":5,"alias":"","type":"markdown-output","locked":true,"hidden":false,"state":{"binding":"md-intro"}},{"id":1,"alias":"prog1","type":"text-input","locked":false,"hidden":false,"state":{"text":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);"}},{"id":6,"alias":"","type":"text-input","locked":true,"hidden":true,"state":{"text":"How can you verify that your program \"correctly\" leaks the secret (no matter what \nit has)? In effect, you have to check for each possible value, that it is leaked \ncorrectly. Run your program with 3-5 different values to check that your leak works:"}},{"id":8,"alias":"","type":"markdown-output","locked":false,"hidden":false,"state":{"binding":"6"}},{"id":21,"alias":"prog1-input","type":"text-input","locked":false,"hidden":false,"state":{"text":"42"}},{"id":20,"alias":"","type":"interpreter-output","locked":false,"hidden":false,"state":{"req":{"programCode":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);","inputFile":"42"},"codeBinding":"prog1","inputBinding":"prog1-input"}},{"id":9,"alias":"","type":"text-input","locked":true,"hidden":true,"state":{"text":"This kind of leak is called a \"direct flow\", since the secret value is at\nsome point assigned (directly) from the secret variable to a public variable\n(which is then output). Fortunately, direct flows are easy to discover in a program;\nin fact it can be done mechanically/automatically using our well known *taint analysis*.\nBelow, show and explain how taint analysis can be used to detect the leak in the\nabove program."}},{"id":10,"alias":"","type":"markdown-output","locked":false,"hidden":false,"state":{"binding":"9"}},{"id":2,"alias":"","type":"analysis-output","locked":false,"hidden":false,"state":{"req":{"programCode":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);","analysisName":"While-taint","stepCount":0},"binding":"prog1"}},{"id":11,"alias":"md-indirect","type":"text-input","locked":false,"hidden":true,"state":{"text":"# Task 2: Indirect Flows\n\nSo far so good. We now have an *automatic* way to guarantee that a program does\nnot (directly) leak any secrets... unfortunately that is not enough: there is still\na way to leak secrets through so-called *indirect flows*: change the program below\nso that it (1) outputs the secret (verify in the same way as above) and \n(2) *passes* the taint analysis, i.e., the  `public` variable should be *untainted* \n(have the taint value $\\bot$) in the taint analysis of the program (verify using the\ntaint analysis)."}},{"id":12,"alias":"","type":"markdown-output","locked":false,"hidden":false,"state":{"binding":"md-indirect"}},{"id":3,"alias":"prog2","type":"text-input","locked":false,"hidden":false,"state":{"text":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);"}},{"id":22,"alias":"prog2-input","type":"text-input","locked":false,"hidden":false,"state":{"text":"42"}},{"id":23,"alias":"","type":"interpreter-output","locked":false,"hidden":false,"state":{"req":{"programCode":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);","inputFile":"42"},"codeBinding":"prog2","inputBinding":"prog2-input"}},{"id":4,"alias":"","type":"analysis-output","locked":false,"hidden":false,"state":{"req":{"programCode":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);","analysisName":"While-taint","stepCount":0},"binding":"prog2"}},{"id":13,"alias":"","type":"text-input","locked":true,"hidden":true,"state":{"text":"## Extending the taint analysis\n\nClearly the \"normal\" taint analysis is not sufficiently precise to detect indirect\nflows, making it largely unusable for enforcing secure information flow. This raises \nthe question: How can the taint analysis be extended to also detect *indirect flows*?\n\nShow how your extended taint analysis can detect the above \"indirect flow\" attack."}},{"id":14,"alias":"","type":"markdown-output","locked":false,"hidden":false,"state":{"binding":"13"}},{"id":17,"alias":"md-sidechannel","type":"text-input","locked":false,"hidden":true,"state":{"text":"# Task 3: Side-Channels\n\nLook carefully at the output from the above test programs. Is there any \ninformation that you can use to leak information? Write a small attack program\nto exploit this *side channel*.\n\n<details>\n<summary>Hint 1</summary>\n\nLook at the output from your attack exploiting indirect flows for different\ninputs: something changes in a way that depends on the input. Can you \nexploit that?\n</details>\n<details>\n<summary>Hint 2</summary>\n\nThe input channel `SYSTEM_STEPS` returns the number of steps/cycles\nthe program has executed so far.\n</details>"}},{"id":18,"alias":"","type":"markdown-output","locked":false,"hidden":false,"state":{"binding":"md-sidechannel"}},{"id":41,"alias":"prog3-HINT","type":"text-input","locked":true,"hidden":true,"state":{"text":"The number of steps/cycles spent so far can be accessed\nthrough the channel \"SYSTEM_STEPS\":\n\n  st = input(SYSTEM_STEPS);"}},{"id":15,"alias":"prog3","type":"text-input","locked":false,"hidden":false,"state":{"text":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);"}},{"id":25,"alias":"prog3-input","type":"text-input","locked":false,"hidden":false,"state":{"text":"42"}},{"id":26,"alias":"","type":"interpreter-output","locked":false,"hidden":false,"state":{"req":{"programCode":"secret = input(HIGH);\n/* INSERT YOUR ATTACK HERE */\noutput(public);","inputFile":"42"},"codeBinding":"prog3","inputBinding":"prog3-input"}},{"id":30,"alias":"md-termination","type":"text-input","locked":false,"hidden":true,"state":{"text":"## Taint analysis to the rescue... again!\n\nCan you think of a way to use the extended taint analysis to prevent the above\nsidechannel attacks? \n\n<details>\n<summary>Hint 1</summary>\n\nCan you restrict the conditionals?\n</details>\n<details>\n<summary>Hint 2</summary>\n\nMaybe require a particular taint value for variables that occur\nin conditions of `while` loops?\n</details>\n\n# Task 4: A Final(?) Challenge\n\nEven with the above restriction, it may still be possible to leak information\nthrough (yet another) side channel. \n\n**Hint:** What if the output is not at the end of the program?"}},{"id":31,"alias":"","type":"markdown-output","locked":false,"hidden":false,"state":{"binding":"md-termination"}},{"id":38,"alias":"prog4","type":"text-input","locked":false,"hidden":false,"state":{"text":"secret = input(HIGH);\n/* DO YOUR WORST HERE! */\n/* (hint: maybe output doesn't have to be at the end) */"}},{"id":39,"alias":"prog4-input","type":"text-input","locked":false,"hidden":false,"state":{"text":"42"}},{"id":40,"alias":"prog4-output","type":"interpreter-output","locked":false,"hidden":false,"state":{"req":{"programCode":"secret = input(HIGH);\n/* DO YOUR WORST HERE! */\n/* (hint: maybe output doesn't have to be at the end) */","inputFile":"42"},"codeBinding":"prog4","inputBinding":"prog4-input"}},{"id":36,"alias":"prog4-hint1","type":"text-input","locked":false,"hidden":true,"state":{"text":"secret = input(HIGH);\npublic = 0;\nwhile(1) {\n  if(secret == public) x = 1/0;\n  public = public + 1;\n  output(\"X\");\n}"}},{"id":42,"alias":"prog4-hint1-input","type":"text-input","locked":false,"hidden":true,"state":{"text":"42"}},{"id":43,"alias":"","type":"interpreter-output","locked":false,"hidden":true,"state":{"req":{"programCode":"secret = input(HIGH);\npublic = 0;\nwhile(1) {\n  if(secret == public) x = 1/0;\n  public = public + 1;\n  output(\"X\");\n}","inputFile":"42"},"codeBinding":"prog4-hint1","inputBinding":"prog4-hint1-input"}},{"id":37,"alias":"prog4-hint2","type":"text-input","locked":false,"hidden":true,"state":{"text":"secret = input(HIGH);\npublic = 0;\nwhile(1) {\n  if(secret == public) {\n    while(1)\n      skip;\n  }\n  output(public);\n  public = public + 1;\n}"}},{"id":44,"alias":"prog4-hint2-input","type":"text-input","locked":false,"hidden":true,"state":{"text":"10"}},{"id":45,"alias":"prog4-hint2-output","type":"interpreter-output","locked":false,"hidden":true,"state":{"req":{"programCode":"secret = input(HIGH);\npublic = 0;\nwhile(1) {\n  if(secret == public) {\n    while(1)\n      skip;\n  }\n  output(public);\n  public = public + 1;\n}","inputFile":"10"},"codeBinding":"prog4-hint2","inputBinding":"prog4-hint2-input"}}]}
